/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package se.liu.ida.sambo.Recommendation;

import java.math.RoundingMode;
import java.sql.Connection;
import java.sql.SQLException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;
import se.liu.ida.sambo.Merger.Constants;
import se.liu.ida.sambo.algos.matching.algos.AlgoConstants;
import se.liu.ida.sambo.algos.matching.algos.SinglePairComputation;
import se.liu.ida.sambo.jdbc.ResourceManager;
import se.liu.ida.sambo.util.Pair;

/**
 * <p>
 * Generate artifical wrong mapping suggestions.
 * </p>
 * 
 * @author Rajaram
 * @version 1.0
 */
public class GenerateWrongSuggestions {
       
    /**
     * Name of the ontology pair.
     */ 
    private String ontologiesName = AlgoConstants.settingsInfo.getName(
            Constants.ONTOLOGY_1).concat(AlgoConstants.SEPERATOR).concat(
            AlgoConstants.settingsInfo.getName(Constants.ONTOLOGY_2));    
    /**
     * SQL connection.
     */
    private Connection sqlConn = null;
    /**
     * To compute similarity value for a single concept pair. 
     */
    private SinglePairComputation singlePairCompuation = new 
            SinglePairComputation();
    /**
     * Upper threshold for the editDistance matcher.
     */
    private double upperBound = 0;
    /**
     * Lower threshold for the editDistance matcher.
     */
    private double lowerBound = 0;
    /**
     * Maximum wrong mapping suggestions the user want to generate.
     */
    private double maxSuggestions;
    /**
     * Number of wrong mapping suggestions generated.
     */
    public int suggestionsGenerated = 0;
    /**
     * Default constructor for this class.
     */    
    public GenerateWrongSuggestions(double maxWrong, double maxThreshold, 
            double minThreshold) {
        
        maxSuggestions = maxWrong;
        
        if(maxThreshold == minThreshold) {
            System.out.println("Max and Min thresholds are same. Change the"
                    + " threshold values!!");
            System.exit(0);
        }
        else {
            
            // Finding median.
            double median = (maxThreshold + minThreshold)/2;            
            
            DecimalFormat df = new DecimalFormat("##.#");
            df.setRoundingMode(RoundingMode.DOWN);
            String medianStr = df.format(median);
            /**
             * In Swedish char "." will be written as "," so we need to replace 
             * this.
             */        
            medianStr = medianStr.replace(',', '.');
            median = Double.parseDouble(medianStr);
            
            // Assigning lower bound.
            if((median - 0.1) > 0) {
                lowerBound = median - 0.1;
            }
            else {
                 lowerBound = minThreshold;
            }
            // Assigning upper bound.
            if((median + 0.1) < maxThreshold) {
                upperBound = median + 0.1;
            }
            else {
                 upperBound = maxThreshold;
            }
        }
        
        try {
            sqlConn = ResourceManager.getConnection();
        } catch (SQLException ex) {
            Logger.getLogger(GenerateWrongSuggestions.class.getName()).
                    log(Level.SEVERE, null, ex);
        }        
    }
    
    /**
     * <p>
     * This method randomly select two correct mapping suggestions and swap 
     * their pair to generate wrong mapping suggestions.
     * 
     * (Note:)
     * Most of the time wrong mapping suggestions generated by this method 
     * will have similarity value less than 0.1 for linguistic matcher. 
     * </p>
     * 
     */
    public void randomMethod() {
                
        suggestionsGenerated = 0;        
        Random random = new Random();
        
        for (String correctSuggestion1 : 
                RecommendationConstants.ACCEPTED_SUGGESTIONS) {
            
            if (suggestionsGenerated >= maxSuggestions) {
                break;
            }
            
            String correctSuggestion2 = correctSuggestion1;
            // Randomly selecting a correct mapping suggestion.
            while(!correctSuggestion1.equalsIgnoreCase(correctSuggestion2)) {
                
                int randomNumber = random.nextInt(
                        (RecommendationConstants.ACCEPTED_SUGGESTIONS.
                        size()-1));
                correctSuggestion2 = RecommendationConstants.
                        ACCEPTED_SUGGESTIONS.get(randomNumber);            
            }
            
            
            String []correctSugg1Data = correctSuggestion1.split
                    (AlgoConstants.SEPERATOR);                
            String []correctSugg2Data = correctSuggestion2.split
                    (AlgoConstants.SEPERATOR);                
            // Swaping pairs.    
            String wrongSuggestion1 = correctSugg1Data[0].concat
                    (AlgoConstants.SEPERATOR).concat(correctSugg2Data[1]);                
            String wrongSuggestion2 = correctSugg2Data[0].concat
                    (AlgoConstants.SEPERATOR).concat(correctSugg1Data[1]);
            
            if(!RecommendationConstants.VALIDATED_SUGGESTIONS.
                    contains(wrongSuggestion1) && !RecommendationConstants.
                    GENERATED_REJECTED_SUGGESTIONS.contains(wrongSuggestion1)) {
                               
                RecommendationConstants.GENERATED_REJECTED_SUGGESTIONS
                        .add(wrongSuggestion1);
                suggestionsGenerated++;
            }
            
            if(!RecommendationConstants.VALIDATED_SUGGESTIONS.
                    contains(wrongSuggestion2) && !RecommendationConstants.
                    GENERATED_REJECTED_SUGGESTIONS.contains(wrongSuggestion2)) {
                               
                RecommendationConstants.GENERATED_REJECTED_SUGGESTIONS
                        .add(wrongSuggestion2);
                suggestionsGenerated++;
            }
        }
        
    }
    
    /**
     * <p>
     * This method generate wrong mapping suggestions based on the EditDistance
     * similarity value.
     * </p>
     *      
     */
    public void editDistanceMethod() {
               
        suggestionsGenerated = 0;
        
        for (String correctSuggestion1 : RecommendationConstants.
                ACCEPTED_SUGGESTIONS) {
            
            if (suggestionsGenerated >= maxSuggestions) {
                break;
            }
            
            for(String correctSuggestion2 : RecommendationConstants.
                    ACCEPTED_SUGGESTIONS) {
                
                if (!correctSuggestion2.equalsIgnoreCase(correctSuggestion1)) {
                    
                    String []correctSugg1Data = correctSuggestion1.
                            split(AlgoConstants.SEPERATOR);
                    String []correctSugg2Data = correctSuggestion2.
                            split(AlgoConstants.SEPERATOR);
                    
                    String wrongSugg1 = correctSugg1Data[0].
                            concat(AlgoConstants.SEPERATOR).concat
                            (correctSugg2Data[1]);                
                    String wrongSugg2 = correctSugg2Data[0].concat
                            (AlgoConstants.SEPERATOR).concat
                            (correctSugg1Data[1]);                    
                    
                    // For wrong suggestion 1
                    Object concept1 = AlgoConstants.ontManager.getMOnt
                            (Constants.ONTOLOGY_1).getElement
                            (correctSugg1Data[0]);
                    
                    Object concept2 = AlgoConstants.ontManager.getMOnt
                            (Constants.ONTOLOGY_2).getElement
                            (correctSugg2Data[1]);
                    
                    Pair pair = new Pair(concept1, concept2);
                    
                    
                    double simWrong1= singlePairCompuation.
                            calculateSimilarityValue(AlgoConstants.
                            EDIT_DISTANCE, pair, ontologiesName, sqlConn);
                    
                    // For wrong suggestion 2
                    concept1 = AlgoConstants.ontManager.getMOnt
                            (Constants.ONTOLOGY_1).getElement
                            (correctSugg2Data[0]);
                    
                    concept2 = AlgoConstants.ontManager.getMOnt
                            (Constants.ONTOLOGY_2).getElement
                            (correctSugg1Data[1]);
                    
                    pair = new Pair(concept1, concept2);
                    
                    
                    double simWrong2= singlePairCompuation.
                            calculateSimilarityValue(AlgoConstants.
                            EDIT_DISTANCE, pair, ontologiesName, sqlConn);
                    
                    if (simWrong1 >= lowerBound && simWrong1 <= upperBound ) {
                        
                        if (!RecommendationConstants.VALIDATED_SUGGESTIONS.
                            contains(wrongSugg1) && !RecommendationConstants.
                            GENERATED_REJECTED_SUGGESTIONS.contains
                                (wrongSugg1)) {
                            RecommendationConstants.
                            GENERATED_REJECTED_SUGGESTIONS.add(wrongSugg1);
                            suggestionsGenerated++;
                        }
                    }
                    
                    if (simWrong2 >= lowerBound && simWrong2 <= upperBound ) {
                        
                        if (!RecommendationConstants.VALIDATED_SUGGESTIONS.
                            contains(wrongSugg2) && !RecommendationConstants.
                            GENERATED_REJECTED_SUGGESTIONS.contains
                                (wrongSugg2)) {
                            RecommendationConstants.
                            GENERATED_REJECTED_SUGGESTIONS.add(wrongSugg2);
                            suggestionsGenerated++;
                        }
                    }
                }
            }
        }
    }
        
    private double probabilityCR() {
        
        int noOfCorrectSuggestion = 0;
        
        double pCR = 0;
        
         for (String suggestion : RecommendationConstants.
                 ACCEPTED_SUGGESTIONS) {
             
             String []suggestionData = suggestion.
                            split(AlgoConstants.SEPERATOR);
             
             // For wrong suggestion 1
             Object concept1 = AlgoConstants.ontManager.getMOnt
                     (Constants.ONTOLOGY_1).getElement(suggestionData[0]);
                    
             Object concept2 = AlgoConstants.ontManager.getMOnt
                     (Constants.ONTOLOGY_2).getElement(suggestionData[1]);
                    
             Pair pair = new Pair(concept1, concept2);                    
                    
             double suggestionSimValue= singlePairCompuation.
                     calculateSimilarityValue(AlgoConstants.EDIT_DISTANCE, 
                     pair, ontologiesName, sqlConn);
                    
             if (suggestionSimValue >= lowerBound && 
                     suggestionSimValue <= upperBound ) {
                 noOfCorrectSuggestion++;                    
             }
         }
         
         pCR = noOfCorrectSuggestion / RecommendationConstants.
                 ACCEPTED_SUGGESTIONS.size();         
         
         return pCR; 
    }
    
     private double probabilityMC() {
        
        int noOfCorrectSuggestion = 0;        
        double pMC = 0; 
        
        ArrayList<String> copyAccepted = new ArrayList<String> 
                (RecommendationConstants.ACCEPTED_SUGGESTIONS);
        
        ArrayList<String> copyAccepted2 = new ArrayList<String> 
                (RecommendationConstants.ACCEPTED_SUGGESTIONS);
        
        for(String suggestion : copyAccepted) {
            
            String []suggestionData = suggestion.
                            split(AlgoConstants.SEPERATOR);
            
            int count = 0;
            for(String sugg : copyAccepted2) {
                
                if(sugg.contains(suggestionData[0])) {
                    count++;
                }
                if(count > 1) {
                    noOfCorrectSuggestion++;
                    break;
                }                
            }            
            copyAccepted2.remove(suggestion);
        }
        
        pMC = noOfCorrectSuggestion / RecommendationConstants.
                 ACCEPTED_SUGGESTIONS.size();
        
        return pMC;
     }
     
     public double reductionInWrongSuggestion() {
         double pCR = probabilityCR();
         double pMC = probabilityMC();
         
         int bCR = (int) (pCR * suggestionsGenerated);         
         int bMC = (int) (pMC * suggestionsGenerated);
         
         return (bCR + bMC);
     }
    
}
