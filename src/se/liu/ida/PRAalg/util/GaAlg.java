/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package se.liu.ida.PRAalg.util;

import com.micropraxis.gajit.Chrom;
import com.micropraxis.gajit.ChromItem;
import com.micropraxis.gajit.FixView;
import com.micropraxis.gajit.Population;
import com.micropraxis.gajit.View;
import com.micropraxis.gajit.XOverGeneOp;
import com.micropraxis.util.*;

import java.util.logging.Logger;

/**
 * @author Qiang Liu
 * Created on Sep 5, 2009, 4:53:56 PM
 */
public abstract class GaAlg {
    private static Logger logger = Logger.getLogger(GaAlg.class.getName());
    //the length of a gene
    private final int SIZEGENES = 1;
    //the number of generations
    private final int GENERATIONS = 30;
    //the number of gene in one chromsome
    private final int NUMCHROMS = 100;

    //the number of genes
    private int NUMGENES;
    //set the population of GA algorithm
    private Population people;
    //the enviornment
    private View vista;

    protected abstract double getFitnessValue(int[] choose);
    protected abstract boolean satisfyCondition(int[] choose);


    protected void initalize(int num){
        NUMGENES = num;
        //set the population of GA algorithm
        people = new Population(NUMCHROMS, SIZEGENES, NUMGENES,
                NUMGENES, 1.0 / (SIZEGENES * NUMGENES));
        //initialize the enviornment
        vista = new FixView(SIZEGENES, 0, 1.0);
        //set the parameter for selection rate, cross rate and mutation rate
        XOverGeneOp adder = new XOverGeneOp(SIZEGENES);
        people.setEliteRate(0.05);
        people.setCullRate(0.4);
        people.addOp(adder, 0.1);
    }

     /**
     * Return the selected suggestions forming a consistent suggestion group
     * <p>
     * This function uses genetic algorithm to find the consistent suggestion group
     *
      * @param maxIterNum 
     * @return		the selected suggestions
     */
    public int[] StartFind(int maxIterNum) {
        int[] result = new int[NUMGENES];
        int iterNum = 1;
        do {
            //begin iteration
            for (int i = 0; i < GENERATIONS; ++i) {
                Iterator censo;
                if (i % 10 == 0) {
                    censo = people.iteratorAll();
                } else {
                    censo = people.iteratorNewOnly();
                }
                while (censo.hasNext()) {
                    //chromsomes are generated by random
                    double val = 0.0;
                    ChromItem tmp = (ChromItem) censo.next();
                    Chrom chrom = tmp.getChrom();
                    int geneCount = vista.size(chrom);
                    //choose[i] is a chromsome
                    int[] choose = new int[geneCount];
                    for (int j = 0; j < geneCount; j++) {
                        choose[j] = (int) ((Double) vista.getGene(chrom, j)).doubleValue();
                    }
                    //calculate the fitness
                    val = this.getFitnessValue(choose);
                    tmp.setFitness(val);
                }
                if (i < GENERATIONS - 1) {
                    people.newGeneration();
                }
            }

            SortedList results = new SortedList(people);
            ListIterator iter = results.listIterator(results.size());

            // after the iteration, return the chromsome with the highest fitness value
            while (iter.hasPrevious()) {
                ChromItem item = (ChromItem) iter.previous();
                Chrom chrom = item.getChrom();

                int geneCount = vista.size(chrom);
                result = new int[geneCount];

                for (int j = 0; j < geneCount; j++) {
                    result[j] = (int) ((Double) vista.getGene(chrom, j)).doubleValue();
                }
                logger.finer("Current best fitness value is : " + item.getDoubleFitness());
                break;
            }

            //because the result is found by a genetic algorithm, we can not sure that
            //they satisfy the condition. We need to check them.
            if (this.satisfyCondition(result)) {
                break;
            }
            iterNum++;
            logger.finer("Iteration : " + iterNum);
        } while (iterNum<maxIterNum);
        return result;
    }
    
}
